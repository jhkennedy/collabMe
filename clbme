#!/usr/bin/env python
"""
Get all your collaborators.
"""

from __future__ import absolute_import, division, print_function, unicode_literals
import six

import os
import sys
import argparse

from datetime import date

from pybtex.database import parse_file,Person

from collabme.util import custom_argparse_types as cats
from collabme import name

def parse_args(arg_list=None):
    parser = argparse.ArgumentParser(description=__doc__,
                formatter_class=argparse.ArgumentDefaultsHelpFormatter) 

    parser.add_argument('-b', '--bibtex', 
            type=cats.abs_existing_file,
            help='A bibtex file to collect collaborators from.')
    parser.add_argument('-n', '--name',
            help='Your name to find your co-authors')
    
    paleo = parser.add_mutually_exclusive_group()
    paleo.add_argument('-m', '--max_months', 
            type=cats.positive_int,
            help=' '.join(['Limit the search interval to the past MAX_MONTHS (e.g., NSF: 48 months).', 
                           'Note: this will be rounded to UP the nearest year because citation',
                           'managers only reliably store publication year.']))
    paleo.add_argument('-y', '--max_years', 
            type=cats.positive_int,
            help='Limit the search interval to the past MAX_YEARS (e.g., NSF: 4 years).')

    #volume = parser.add_mutually_exclusive_group()
    #volume.add_argument("-v", "--verbose", help="Increase the output verbosity", action="store_true")
    #volume.add_argument("-q", "--quiet",   help="Run silently",                  action="store_true")
    
    args = parser.parse_args(arg_list)
    
    current_year = date.today().year  
    if args.max_months:
        args.search_limit = current_year + (-args.max_months//12)  # // rounds down
    elif args.max_years:
        args.search_limit = current_year - args.max_years
    else:
        args.search_limit = 0

    return args


def main(args):
    bib = parse_file(args.bibtex)

    me = Person(args.name)

    #NOTE: using a dict here ensures uniqueness of full names
    all_people = {}
    for key, entry in six.iteritems(bib.entries):
        #first, make sure that we are a co-author with these people
        #There must be a more efficient way than this
        flag = False
        
        #wrap this into a try except, in case your bib file contains
        #entries with no authors (e.g. monitored folders do that)
        try:
            for person in entry.persons.values()[0]:
                if me.last_names == person.last_names:
                    flag = True
        except IndexError:
            continue         

        #if our name is in the list of authors for that paper
        #add the co-authors to the output list
        if flag:
            #do that only for the minimum number of months required
            if int(entry.fields['year']) >= args.search_limit:
                for person in entry.persons['author']:
                    all_people[name.full(person)] = person

    #NOTE: Sort by last name
    for person in sorted(all_people.values(), key=name.sort_on_last):
        full_name = name.full(person)
        print(full_name.replace('~',' ')) 

if __name__ == '__main__':
    main(parse_args())
